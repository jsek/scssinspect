// Generated by CoffeeScript 1.8.0
var EventEmitter, Inspector, Match, astToCSS, fs, parse, util,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

util = require('util');

EventEmitter = require('events').EventEmitter;

parse = require('./parser/gonzales-pe').cssToAST;

fs = require('fs');

Match = require('./match');

astToCSS = require('./css').astToCSS;

Inspector = (function(_super) {
  __extends(Inspector, _super);

  function Inspector(_filePaths, opts) {
    this._filePaths = _filePaths != null ? _filePaths : [];
    if (opts == null) {
      opts = {};
    }
    this._threshold = opts.threshold || 15;
    this._ignoreValues = opts['ignore-values'];
    this._diff = opts.diff;
    this._hash = Object.create(null);
    this.numFiles = this._filePaths.length;
    if (this._diff) {
      this._fileContents = {};
    }
  }

  Inspector.prototype.run = function() {
    var contents, filePath, opts, _i, _len, _ref;
    opts = {
      encoding: 'utf8'
    };
    this.emit('start');
    _ref = this._filePaths;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      filePath = _ref[_i];
      filePath = filePath.replace(/\//g, '\\');
      contents = fs.readFileSync(filePath, opts);
      if (this._diff) {
        this._fileContents[filePath] = contents.split('\n');
      }
      this._parse(filePath, contents);
    }
    this._analyze();
    return this.emit('end');
  };

  Inspector.prototype._parse = function(filePath, contents) {
    var syntaxTree;
    syntaxTree = parse({
      css: contents,
      syntax: 'scss',
      needInfo: true
    });
    return this._walk(syntaxTree, (function(_this) {
      return function(rule) {
        _this._insert(rule);
        return rule.loc.source = filePath;
      };
    })(this));
  };

  Inspector.prototype._analyze = function() {
    var key, match, rules, _results;
    _results = [];
    for (key in this._hash) {
      rules = this._hash[key];
      if ((rules != null ? rules.length : void 0) > 1) {
        match = new Match(rules);
        if (this._diff) {
          match.generateDiffs(this._fileContents);
        }
        _results.push(this.emit('match', match));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Inspector.prototype._walk = function(syntaxTree, fn) {
    var block, ruleset, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = syntaxTree.length; _i < _len; _i++) {
      ruleset = syntaxTree[_i];
      if (!(ruleset[1] === 'ruleset')) {
        continue;
      }
      fn(ruleset);
      _results.push((function() {
        var _j, _len1, _results1;
        _results1 = [];
        for (_j = 0, _len1 = ruleset.length; _j < _len1; _j++) {
          block = ruleset[_j];
          if (block[1] === 'block') {
            _results1.push(this._walk(block, fn));
          }
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  Inspector.prototype._insert = function(rule) {
    var key;
    key = this._getHashKey(rule);
    if (!this._hash[key]) {
      this._hash[key] = [];
    }
    return this._hash[key].push(rule);
  };

  Inspector.prototype._getHashKey = function(ruleset) {
    var structure, _ref, _ref1;
    structure = astToCSS({
      ast: ruleset,
      syntax: 'scss'
    });
    ruleset.pos = "(" + (Math.round(ruleset[0].ln / 2)) + ", " + (Math.round(((_ref = ruleset[0].end) != null ? _ref.ln : void 0) / 2)) + ")";
    ruleset.loc = {
      start: {
        line: Math.round(ruleset[0].ln / 2)
      },
      end: {
        line: Math.round(((_ref1 = ruleset[0].end) != null ? _ref1.ln : void 0) / 2)
      }
    };
    return structure;
  };

  return Inspector;

})(EventEmitter);

module.exports = Inspector;
