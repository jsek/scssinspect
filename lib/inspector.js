var EventEmitter, Inspector, Match, _, anonymizer, astToCSS, beautify, fs, parse, util,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

util = require('util');

EventEmitter = require('events').EventEmitter;

parse = require('../parser/gonzales').cssToAST;

fs = require('fs');

beautify = require('js-beautify').js_beautify;

Match = require('./match');

astToCSS = require('./printer').astToCSS;

anonymizer = require('./anonymizer')();


/*
 * Inspector will walk through the given files, parse them, split into rulesets
 * and generates hash for all of them. In case there is more than one ruleset with
 * the same hash, they are considered a duplication and will be emited at the end
 * of the process to a reporter.
 */

Inspector = (function(superClass) {
  extend(Inspector, superClass);


  /*
   * Constructor creates a new Inspector. It expects array of filepaths and the
   * options. Default values are applied for the values that are only applicable 
   * to Inspector class (defaults for values used by Inspector and reporters
   * are being set on the higher level).
   */

  function Inspector(_filePaths, opts) {
    this._filePaths = _filePaths != null ? _filePaths : [];
    if (opts == null) {
      opts = {};
    }
    this._threshold = opts.threshold === 0 ? 0 : opts.threshold || 50;
    this._thresholdType = opts.thresholdType || 'char';
    this._anonymize = opts.anonymize || [];
    this._language = opts.language || 'scss';
    this._syntax = opts.syntax;
    this._skip = opts.skip;
    this._diff = opts.diff;
    this._ignoreValues = opts.ignoreValues;
    this._hash = Object.create(null);
    this.numFiles = this._filePaths.length;
    if (this._diff !== 'none') {
      this._fileContents = {};
    }
  }


  /*
   * Execute main action - walk through the files. In case of any parsing error
   * inspector decides to throw an error or just emit warning.
   */

  Inspector.prototype.run = function() {
    var contents, err, filePath, i, len, opts, ref;
    opts = {
      encoding: 'utf8'
    };
    this.emit('start');
    ref = this._filePaths;
    for (i = 0, len = ref.length; i < len; i++) {
      filePath = ref[i];
      filePath = filePath.replace(/\//g, '\\');
      contents = fs.readFileSync(filePath, opts);
      if (this._diff !== 'none') {
        this._fileContents[filePath] = contents.split('\n');
      }
      try {
        this._parse(filePath, contents);
      } catch (_error) {
        err = _error;
        if (this._skip) {
          this.numFiles--;
          this.emit('warning', {
            message: 'Cannot parse file',
            path: filePath,
            error: err
          });
        } else {
          throw err;
        }
      }
    }
    if (!this._syntax) {
      this._analyze();
      return this.emit('end');
    }
  };


  /*
   * If the flag --syntax is used, we only parse to get the tree printed in the 
   * console. Otherwise parser gets 'needInfo' option to set location info for
   * each node and then we walk through syntax tree and group matching rulesets.
   */

  Inspector.prototype._parse = function(filePath, contents) {
    var syntaxTree;
    if (this._syntax) {
      syntaxTree = parse({
        css: contents,
        syntax: this._language
      });
      return console.log(beautify(JSON.stringify(syntaxTree)));
    } else {
      syntaxTree = parse({
        css: contents,
        syntax: this._language,
        needInfo: true
      });
      return this._walk(syntaxTree, (function(_this) {
        return function(rule) {
          _this._insert(rule);
          return _this._setMetadata(rule, filePath);
        };
      })(this));
    }
  };


  /*
   * Emit 'match' event for all rulesets that had the same hash generated by the
   * Inspector. Diff is not generated if --diff flag is set to 'none'.
   */

  Inspector.prototype._analyze = function() {
    var key, match, results, rules, size;
    results = [];
    for (key in this._hash) {
      rules = this._hash[key];
      if ((rules != null ? rules.length : void 0) > 1) {
        size = this._getMaxSize(rules);
        if (size >= this._threshold) {
          match = new Match(rules, size);
          if (this._diff !== 'none') {
            match.generateDiffs(this._fileContents, this._diff);
          }
          results.push(this.emit('match', match));
        } else {
          results.push(void 0);
        }
      } else {
        results.push(void 0);
      }
    }
    return results;
  };


  /*
   * Hash generation for each ruleset. There are several types of nodes that can
   * represent block of rules, so we use only them and their children.
   */

  Inspector.prototype._walk = function(syntaxTree, fn) {
    var block, i, len, ref, results, ruleset;
    results = [];
    for (i = 0, len = syntaxTree.length; i < len; i++) {
      ruleset = syntaxTree[i];
      if (!((ref = ruleset[1]) === 'ruleset' || ref === 'mediaquery' || ref === 'include' || ref === 'mixin')) {
        continue;
      }
      fn(ruleset);
      results.push((function() {
        var j, len1, results1;
        results1 = [];
        for (j = 0, len1 = ruleset.length; j < len1; j++) {
          block = ruleset[j];
          if (block[1] === 'block') {
            results1.push(this._walk(block, fn));
          }
        }
        return results1;
      }).call(this));
    }
    return results;
  };


  /*
   * Generate hash and check if it does exceed threshold. Than push the ruleset
   * to the dictionary organized by hash.
   */

  Inspector.prototype._insert = function(rule) {
    var i, key, len, ref, ruleCopy, type;
    ruleCopy = _.cloneDeep(rule);
    ref = this._anonymize;
    for (i = 0, len = ref.length; i < len; i++) {
      type = ref[i];
      anonymizer.anonymize(ruleCopy, type, true);
    }
    key = this._tidy(ruleCopy);
    if (!this._hash[key]) {
      this._hash[key] = [];
    }
    return this._hash[key].push(rule);
  };


  /*
   * Get the biggest size of duplication from all the rules
   */

  Inspector.prototype._getMaxSize = function(rules) {
    var r;
    return Math.max.apply(null, (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = rules.length; i < len; i++) {
        r = rules[i];
        results.push(this._getSize(this._tidy(r), r));
      }
      return results;
    }).call(this));
  };


  /*
   * Choose a method and calculate the size of duplication.
   */

  Inspector.prototype._getSize = function(hash, syntaxTree) {
    var ref;
    if (this._thresholdType === 'char') {
      return hash.length;
    } else if (this._thresholdType === 'token') {
      return parse({
        css: hash,
        syntax: this._language,
        needInfo: true,
        sizeOnly: true
      });
    } else if (this._thresholdType === 'property') {
      return (ref = JSON.stringify(syntaxTree).match(/"declaration",\[\{[^\}]+\},"property"/g)) != null ? ref.length : void 0;
    } else {
      throw new Error('Unknown type of element to apply threshold');
    }
  };


  /*
   * Use modified printer that omits comments, minifies whitespaces and sorts
   * the selectors and rules.
   */

  Inspector.prototype._tidy = function(ruleset) {
    var minCss;
    minCss = astToCSS({
      ast: ruleset,
      syntax: this._language
    });
    return minCss;
  };


  /*
   * Set location and type for given ruleset
   */

  Inspector.prototype._setMetadata = function(ruleset, filePath) {
    var ref;
    ruleset.type = 'ruleset';
    return ruleset.loc = {
      source: filePath,
      start: ruleset[0].ln,
      end: (ref = ruleset[0].end) != null ? ref.ln : void 0
    };
  };

  return Inspector;

})(EventEmitter);

module.exports = Inspector;
