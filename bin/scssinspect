#!/usr/bin/env node

var fs        = require('fs');
var path      = require('path');
var strip     = require('strip-json-comments');
var chalk     = require('chalk');
var filepaths = require('node-filepaths');
var program   = require('commander');
var Inspector = require('../lib/inspector');
var reporters = require('../lib/reporters');

var summary = '  Duplicate code and structure detection for Scss.\n' +
          '  Values matching is enabled by default. Example use:\n' +
          '  scssinspect --ignore \"merged.scss\" ./path/to/src\n';

program
  .version(require('../package.json').version)
  .usage('[options] <paths ...>\n\n' + summary)
//  .option('-t, --threshold <number>'    , 'number of nodes (default: 15)', parseInt)
//  .option('-i, --ignore-values'         , 'don\'t match exact numeric/color values')
  .option('--syntax'                    , 'print syntax trees only')
  .option('-c, --config'                , 'path to config file (default: .scssinspectrc)')
  .option('-s, --skip'                  , 'skip files with parsing errors')
  .option('-r, --reporter <name>'       , 'specify the reporter to use (you can also set custom path to *.js file)')
//  .option('-s, --suppress <number>'     , 'length to suppress diffs (default: 100, off: 0)', parseInt)
  .option('-D, --no-diff'               , 'disable 2-way diffs')
  .option('-C, --no-color'              , 'disable colors')
  .option('--ignore <pattern>'          , 'ignore paths matching a regex')
  .parse(process.argv);

// Check and parse the config file, if it exists
var rcPath = path.resolve(process.cwd(), program.config || '.scssinspectrc');
var opts = {
    encoding: 'utf8'
};

if (fs.existsSync(rcPath) && fs.lstatSync(rcPath).isFile()) {
    try {
        var rcContents = strip(fs.readFileSync(rcPath, opts));
        var rc = JSON.parse(rcContents);
    } catch (e) {
        console.log('Invalid config file:', e.message);
        process.exit(1);
    }

  ['diff', 'ignore', 'reporter', 'skip']
      .forEach(function (option) {
        if (program[option] === undefined && (option in rc)) {
            program[option] = rc[option];
        }
    });
}

// Assume all unconsumed arguments are paths
var suppliedPaths = (program.args.length) ? program.args : ['.'];

// chalk doesn't support short flags by default
if (!program.color) {
    chalk.enabled = false;
}

// Ignore node_modules by default, along with ignore arg
var ignorePatterns = ['node_modules'];
if (program.ignore) {
    ignorePatterns.push(program.ignore);
}

var paths;
try {
    paths = filepaths.getSync(suppliedPaths, {
        suffix: '.scss',
        ignore: ignorePatterns
    });
} catch (e) {
    console.log(e.message);
    process.exit(3);
}

if (!paths.length) {
    console.log('No files found for given list of paths');
    process.exit(0);
}

var inspector = new Inspector(paths, {
    threshold       : program.threshold,
    diff            : program.diff,
    skip            : program.skip,
    syntax          : program.syntax,
    'ignore-values' : program['ignore-values']
});

// Retrieve the requested reporter
var reporterType;
if (/[\\\/]/g.test(program.reporter)) {
    reporterType = require(process.cwd() + program.reporter.replace(/^.\\/,'\\'));
} else {
    reporterType = reporters[program.reporter] || reporters.default;
}
new reporterType(inspector, {
    diff        : program.diff,
    suppress    : program.suppress
});

// Track the number of matches
var matchesCount = 0;
inspector.on('match', function () { matchesCount++; });

try {
    inspector.run();
    process.exit(matchesCount);
} catch (err) {
    console.log(err);
    console.log(err.stack);
    process.exit(1);
}